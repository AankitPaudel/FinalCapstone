Welcome, my name is Terry Soule, and this is Programming Chaos, a channel devoted to fun and interesting programming projects to help you hone your programming skills. Today's project is the Sierpinski triangle, also known sometimes as the Sierpinski gasket or Sierpinski sieve. It's one of the classic fractal shapes. As you can see here, it consists of a large triangle with three smaller triangles drawn around it. Then, each of those smaller triangles has successively smaller triangles around it, making it a fractal shape that repeats at different scales. Not surprisingly, we're going to program it using recursion.

We’re going to write a triangle function that draws a triangle and then calls itself to draw the three smaller triangles around it. And because it's calling itself, each of those triangles will draw three smaller triangles, and so on. We'll put our own little spin on it to make it more interesting. Now, before we start the coding, we should do a little bit of geometry to make sure that we get the sizes and the positioning correct for the triangles. I’m going to do mine in a slightly different way for reasons that will become apparent. I'm going to focus on making a triangle function where you give it the center of the triangle, and that'll help drive the geometry.

So here we have one iteration of our recursive function. We have the main triangle and then the three smaller ones around it. The idea is that our triangle function will be given the center of the triangle and the length of a side. From that, we need to figure out where our points are, i.e., where do we draw the vertices of our main triangle? We'll also need to figure out where the centers of the three secondary triangles are.

We can begin with this point here. The x-coordinate is pretty simple—it's zero. If this is the center, it's the same as the center, so we offset by zero. The y-value gets trickier. It looks like it might be half the side, but that isn't true because this is the length of the side; it's half of this distance. In order to calculate this distance, we need to use a little bit of trigonometry. The angle here is 60°, and half that angle is 30° (or π/6 radians). If we take the side times the cosine of π/6, we get this length. What we want is the y-value, which is actually half that length. We’ll be using that formula quite a bit—this length that's half of the side, times the cosine of π/6, gives us this length here, and that is the y-value for this point in the negative direction. It's the y-value for these two points in the positive direction.

We also have to know this x-distance. That's easy. It is just half of a side because this is an equilateral triangle. So all the sides are the same, and this distance is also half of a side. So that solves the problem of drawing the triangle. When we write it out in code, it'll be a little clearer.

Next, we need to figure out where the centers of the other three triangles are. This one lines up here, so the x-distance is again half of a side. The y-distance is half of this length, and the center of this triangle is over by half of a side, in the positive direction. The distance up is half of that length. For the other triangle, the x-coordinate is zero because it's lined up with our translated origin, and the y-coordinate is 1.5 times this length—one length plus another half of a length.

Additionally, each triangle has sides that are half as big, so the side here is half of this side. That gives us the geometry we need, and once we get the code written, it will become more clear.

Now that we have the geometry, let's start programming. The first thing I’m going to do is create the myTriangle function, which will draw a triangle. Eventually, we’ll make it recursive, but we’ll start by just drawing a single triangle. I’ll call it myTriangle because Processing has a built-in triangle function that we will take advantage of.

What we need to tell this function is the x-y location of the center of the triangle and the length of the side. I’m going to translate to the x-y position in the center of the triangle, and from there, we’ll do all of our calculations. We’ll need to use push and pop matrix transformations to translate properly.

Now, we can draw the triangle using the geometry we drew before. The first thing we'll need is the length, which will be used to calculate where the vertices are. There’s our length, and now we can start drawing the actual triangle. We’ll start with the first point, which is at the x-value lined up with the origin but moved up by negative the length. The second vertex is moved over by half the side and down by the length, and the third vertex is moved by half a side and down by the length. That should draw the triangle for us.

Let's test it by putting the triangle in the middle of the screen and setting the side length to 300. That looks pretty good! We can make the triangle a little bigger, but I’ll stick with this size for now.

Now, we need to add the recursive function calls. First, I’ll begin by drawing the triangle below the main one. We’ll need to add a stopping condition so that the recursion only occurs if the side length is still reasonably long. I’ll use 4 as the test condition for this. Now, all I need to do is call myTriangle but with the new position, drawing it underneath. The x-position doesn’t change, but as we saw in the geometry, the y-position is 1.5 times the length, and the size is half as large.

Now we have our recursive triangles drawn underneath the main triangle. It's a good idea in recursive fractal patterns like this to do one at a time. If we try to do all three triangles at once, we might get a mess on the screen, and it will be hard to debug. So it’s best to proceed with small steps.

There’s our first triangle. Now, for the second triangle, we can draw it off to the left. We already know that the distance to the left is half the side, and the distance up is half that length. Once again, the size will be half as large. Now we have the triangles off to the left, and we’re starting to fill in half of the fractal pattern.

The final triangle is just a copy of the second one, but it's in the positive x-direction. Now we have the basic Sierpinski triangle. It's upside down from the way it's often seen, but that’s just because I find it easier to think of the individual triangles facing up, which makes the whole pattern face down.

Once this is done, you can play around with different effects. For example, I made my triangles a little bit smaller to get a more “exploded” look. You can also remove the stroke to get a more snowflake-like look, or change the hue of the triangles over time. You can even place images inside the triangles for an added twist.

To do that, you need to find a transparent PNG image and place it in the data folder of your project. Then you’ll create a PImage object to store the image and load it into your program. After drawing the triangle, you can display the image on top. You'll need to adjust the image’s scale and positioning to fit inside each triangle. By scaling the image based on the side length and shifting it into the correct position, you can achieve a nice effect where each triangle has an image inside.

