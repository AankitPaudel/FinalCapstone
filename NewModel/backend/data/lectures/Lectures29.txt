Welcome, my name is Terry Soul, and this is Programming Chaos, a channel devoted to fun and interesting programming projects to help you hone your programming skills. For today's project, we're literally going to be programming chaos. That is to say, I'm going to be programming the Lorenz model, which is one of the very first chaotic systems that was identified. In fact, it was instrumental in even identifying what chaos is from a mathematical perspective. As you can see here, chaotic systems give you these very intricate, very interesting-looking forms, and there's really an infinite number of chaotic systems. This just happens to be both one of the very first and one that is reasonably easy to program and gives some interesting results.

So, what is a chaotic system? Well, in order to understand that, it's actually helpful to go through and do the code, and then we can explore the code. In this case, as I said, it's the Lorenz model that we're doing, which is a differential equation model of three variables. So let's take a look at those equations that define these three variables. These are the three equations that define the Lorenz model. Edward Lorenz studied weather, and so these equations you can think of them as relating to things like temperature, pressure, and humidity, although we'll just worry about X, Y, and Z. These are different equations, which means what they tell us is how those variables X, Y, and Z change over time.

So, this somewhat complicated-looking dx/dt basically tells us if we look ahead a teeny step in time (that's the DT), this will tell us how much X changes by. And so, X changes by an amount that depends on Y and X and a parameter P. Then we have another differential equation for Y, so this tells us how Y will change, and then similarly, we know how Z will change just a little bit in time. Z changes depending on X, Y, and Z. So this is a set of differential equations which will tell us how X, Y, and Z change. Because these values are being treated as X, Y, and Z, we can plot that as a point in space. What we're really going to be seeing is a point moving around in space, which we saw in the intro.

There are a couple of things to notice about these equations. These are purely deterministic. There's nothing random in here. We know exactly what X is going to be at the next time step. We know exactly what Y is going to be at the next time step. So chaos and chaotic systems are different from random systems. Chaotic systems are purely deterministic. Sometimes they have some random noise added, but that's not an important feature of a chaotic system.

The other thing that's important to note—and it's not obvious here—is that there's no what's known as a closed-form solution. There's no formula that I can write down that I can plug in time (say, an hour from now) and figure out from that formula what X, Y, and Z are. If I want to know what X, Y, and Z are going to be an hour from now, I have to take that one little step at a time. And if I do that, I can figure out what they will be an hour from now. But there is no closed-form formula. There's no formula that I can plug in T and get the answer out. If it helps, an example where there is a closed-form solution is a very simple example: If I have a car that's going 60 miles an hour, the distance it travels is equal to velocity times time. So if it's going 60 miles an hour and I plug in 10 hours, then I know it's gone 600 miles. And if I plug in 10,000 hours, I know it's gone 600,000 miles. So there's a formula where I can plug in time and know exactly the distance it traveled. I don't have to calculate the next position of the car every millisecond and project into the future. I can just use that closed-form solution to get an answer.

For chaotic systems like this one, that kind of closed-form solution doesn't exist.

Okay, so in terms of the coding, basically what this means is we're going to know the value of X, Y, and Z initially, and then we're going to calculate how much they change by and add that to the old value. Now, in my case, because as you saw, I want something that can rotate, that means I'm going to have to redraw all of the points each time. So, in fact, I'm going to, when I calculate an XYZ value, add it onto an array that keeps track of all of the past history so that I can keep redrawing them. That mostly is just so that we can do rotations with it.

With that in mind, let's start coding. I'm using Processing, which you can download from processing.org. It's really Java in a particular environment that makes it nice to use the graphics. This is sort of the boilerplate we always start with, with a setup function and a draw function. Now, in order to set up my Lorenz model, I'm going to need the variables for X, Y, and Z, and I'll just set those as all being at 10, which is not a bad starting location. I also need my parameters P, R, and B, so let's put those in. These are the three commonly used parameters for this model. One of the key features of a chaotic system is that it is very sensitive to the parameters that you pick. So if you change these parameters a little bit, you may get— in fact, you should get—a very different pattern. So one of the interesting things to play with is trying different parameters here.

I also need a DT, that is that little time step, because if I simply use the formulas as written, the jumps are going to be a little too big, and I'm not actually going to model the system well. There we go. This is roughly the equivalent of saying, "Well, I'm not going to step ahead 1 second at a time. I'm going to step ahead one 100th of a second at a time." So I'm going to take very little steps. If you take steps that are too big, you're not really following the model anymore. And it turns out, although it's not obvious when we draw this, it's going to be fairly small. And so I want to scale it up. So this is just going to be a scaling factor to make it look a little bigger on the screen. And the last thing I need is—as I said—I'm going to want to remember each of the points that we've already plotted. So I'm going to create an array list so I can keep adding the points to that, and it will be an array list of P vectors because I want to keep track of the location of the point in three-space: X, Y, Z.

So those are the variables that I'm going to need, and now I can start to use them. The next thing I need to do is create my array of points, and I like to do a lot of my projects using hue-saturation-brightness color space. So I'm going to change my color mode to be based on, instead of red-green-blue, hue-saturation-brightness where the hue is based on the color wheel (360 degrees) and saturation and brightness go from 0 to 100.

Okay, so that's just the setup part of the program, and now I need to program the draw loop. I'm going to move this up a little bit. There we go. So the first thing I need to do is calculate the new values for X, Y, and Z using those three equations that were defined before. There we go. So that's my first equation: the new value for X is the old value of X plus that formula defined by dx/dt and then multiplied by DT. That's my scaling factor of 0.1. So I'm just going to take small steps at a time as I trace out how X, Y, and Z change.

Programming differential equations is actually fairly simple, and the thing to be careful about is you have to do it in very small steps in order to accurately trace the model. Now we do the same thing with Y and Z. So that gives me my new X, Y, and Z location, and I'm going to put those into a P vector that I can then add to my list of points. As I said, if I just plot the P vector itself, I'm going to get a fairly small pattern in the middle of the screen. A little experimentation said I need to scale it up, so I'm going to take that temporary value and multiply it by the scaling factor that I defined before. So basically, I'm scaling everything up by a factor of 8 just to make it look bigger on the screen.

Now, I can add that to my array of points. So if I run this, I will get an array of points that basically map out the XYZ location, which is the next point in the series defined by these differential equations. Of course, this isn't actually going to draw anything yet. It's just adding them to the array. So now what I need to do is draw all of the points in the array, and to do that, I'm going to need to do a little bit of translation just to get it centered nicely on the screen. It will also allow me to make it rotate eventually.

So, in Processing, the first thing I need to do is push the current coordinate system— which is to say, the current matrix, which defines the coordinate system—onto a stack so I can remember it for later. Then I can do transformations. So first, I need to translate towards the middle of my window. In general, these values sort of move around zero, which would be off in the upper-left corner where we couldn't see it well. So I'm going to translate so that I'm drawing them near the middle of the screen. And then I'm going to start rotating.

There's a neat trick in Processing where you can give it a vector to define the axis of rotation. So, in this case, I'm going to rotate about the X axis by a certain angle. I'm going to rotate about the Y axis by a different angle. And then we just keep rotating around and around, and that will help us visualize the pattern in three dimensions.

Next, I'm going to get rid of the old coordinate system by popping it off the stack and move on to the next frame of the animation. Now that I'm drawing all of my points, I can make it animate by making the rotation angle increase every time. The result is that you get the Lorenz attractor, which is this strange attractor that looks like a butterfly.







